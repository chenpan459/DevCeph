╔═══════════════════════════════════════════════════════════════════════════╗
║           RBD (RADOS Block Device) 架构详细可视化                         ║
╚═══════════════════════════════════════════════════════════════════════════╝

═══════════════════════════════════════════════════════════════════════════════
                        一、RBD 整体架构分层
═══════════════════════════════════════════════════════════════════════════════

┌───────────────────────────────────────────────────────────────────────────┐
│                           应用层                                           │
│                                                                            │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐ │
│  │  虚拟机      │  │  容器        │  │  数据库      │  │  裸金属      │ │
│  │  (QEMU/KVM)  │  │  (Docker/K8s)│  │  (MySQL/PG)  │  │  (直接使用)  │ │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘ │
│         │                 │                 │                 │          │
└─────────┼─────────────────┼─────────────────┼─────────────────┼──────────┘
          │                 │                 │                 │
┌─────────┼─────────────────┼─────────────────┼─────────────────┼──────────┐
│         │      块设备接口层                  │                 │          │
│         │                 │                 │                 │          │
│         ▼                 ▼                 ▼                 ▼          │
│   ┌──────────┐      ┌──────────┐     ┌──────────┐     ┌──────────┐    │
│   │/dev/rbd0 │      │/dev/rbd1 │     │/dev/rbd2 │     │/dev/rbd3 │    │
│   │(块设备)  │      │(块设备)  │     │(块设备)  │     │(块设备)  │    │
│   └────┬─────┘      └────┬─────┘     └────┬─────┘     └────┬─────┘    │
│        │                 │                │                 │          │
│        └─────────────────┴────────────────┴─────────────────┘          │
│                          │                                              │
└──────────────────────────┼──────────────────────────────────────────────┘
                           │
      ┌────────────────────┴────────────────────┐
      │                                         │
      ▼                                         ▼
┌──────────────────────┐              ┌──────────────────────┐
│   内核模块 (krbd)    │              │  用户态库 (librbd)   │
│                      │              │                      │
│ drivers/block/rbd.c  │              │ src/librbd/          │
│ • 内核态实现         │              │ • 用户态实现         │
│ • 更高性能           │              │ • 更多特性           │
│ • 系统级集成         │              │ • 易于调试           │
└──────────┬───────────┘              └──────────┬───────────┘
           │                                     │
           └─────────────────┬───────────────────┘
                             │
┌────────────────────────────┼─────────────────────────────────────────────┐
│              RBD 核心层    │                                              │
│                            │                                              │
│                            ▼                                              │
│      ┌─────────────────────────────────────────────────────┐             │
│      │          ImageCtx (Image 上下文)                    │             │
│      │  • name, id, size                                   │             │
│      │  • features, flags                                  │             │
│      │  • snapshots, parent                                │             │
│      │  • locks, watchers                                  │             │
│      └──────────────────────┬──────────────────────────────┘             │
│                             │                                             │
│         ┌───────────────────┼───────────────────┐                        │
│         │                   │                   │                        │
│         ▼                   ▼                   ▼                        │
│   ┌──────────┐        ┌──────────┐        ┌──────────┐                 │
│   │ImageState│        │Operations│        │Exclusive │                 │
│   │ (状态机) │        │ (操作)   │        │Lock      │                 │
│   └──────────┘        └──────────┘        └──────────┘                 │
└─────────────────────────────────────────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│              I/O 处理层                                                   │
│                                                                           │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │            ImageDispatcher (I/O 调度器)                        │     │
│  │                                                                 │     │
│  │  调度链 (Dispatch Chain):                                      │     │
│  │  ┌────────────────────────────────────────────────────────┐   │     │
│  │  │ QosImageDispatch          (QoS 限流)                   │   │     │
│  │  │   ↓                                                     │   │     │
│  │  │ WriteBlockImageDispatch   (写阻塞)                     │   │     │
│  │  │   ↓                                                     │   │     │
│  │  │ RefreshImageDispatch      (元数据刷新)                 │   │     │
│  │  │   ↓                                                     │   │     │
│  │  │ ExclusiveLockImageDispatch(排他锁检查)                 │   │     │
│  │  │   ↓                                                     │   │     │
│  │  │ WriteLogImageDispatch     (持久化写日志 PWL)           │   │     │
│  │  │   ↓                                                     │   │     │
│  │  │ ImageDispatch             (基础 Image 调度)            │   │     │
│  │  └────────────────────────────────────────────────────────┘   │     │
│  └─────────────────────────────┬──────────────────────────────────┘     │
│                                │                                         │
│                                ▼                                         │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │            ImageRequest (Image 层请求)                         │     │
│  │                                                                 │     │
│  │  • 地址映射：Image offset → Object list                        │     │
│  │  • 请求切分：一个大 I/O → 多个 ObjectRequest                   │     │
│  │                                                                 │     │
│  │  示例：write(offset=8MB, length=8MB, order=22(4MB))           │     │
│  │    → ObjectRequest[2]: [8MB, 12MB)  -> object 2               │     │
│  │    → ObjectRequest[3]: [12MB, 16MB) -> object 3               │     │
│  └─────────────────────────────┬──────────────────────────────────┘     │
│                                │                                         │
│                                ▼                                         │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │            ObjectDispatcher (对象调度器)                       │     │
│  │                                                                 │     │
│  │  调度链:                                                        │     │
│  │  ┌────────────────────────────────────────────────────────┐   │     │
│  │  │ CryptoObjectDispatch          (加密)                   │   │     │
│  │  │   ↓                                                     │   │     │
│  │  │ ObjectCacherObjectDispatch    (对象缓存)               │   │     │
│  │  │   ↓                                                     │   │     │
│  │  │ WriteAroundObjectDispatch     (写绕过)                 │   │     │
│  │  │   ↓                                                     │   │     │
│  │  │ SimpleSchedulerObjectDispatch (简单调度)               │   │     │
│  │  └────────────────────────────────────────────────────────┘   │     │
│  └─────────────────────────────┬──────────────────────────────────┘     │
│                                │                                         │
│                                ▼                                         │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │            ObjectRequest (对象层请求)                          │     │
│  │                                                                 │     │
│  │  • ObjectReadRequest       (读请求)                            │     │
│  │  • ObjectWriteRequest      (写请求)                            │     │
│  │  • ObjectDiscardRequest    (Discard 请求)                      │     │
│  │  • ObjectWriteSameRequest  (WriteSame 请求)                    │     │
│  │  • ObjectCompareAndWriteRequest (CAS 请求)                     │     │
│  │                                                                 │     │
│  │  处理：                                                         │     │
│  │  • 分层 (Layering)                                             │     │
│  │  • Copyup                                                       │     │
│  │  • Object Map 更新                                             │     │
│  └─────────────────────────────┬──────────────────────────────────┘     │
└────────────────────────────────┼─────────────────────────────────────────┘
                                 │
                                 ▼
┌─────────────────────────────────────────────────────────────────────────┐
│              librados 层 (RADOS 客户端)                                  │
│                                                                           │
│  • CRUSH 计算：object_name → PG → OSDs                                   │
│  • 连接 OSD                                                              │
│  • 发送 RADOS 操作 (MOSDOp)                                              │
│  • 接收响应 (MOSDOpReply)                                                │
└────────────────────────────┬────────────────────────────────────────────┘
                             │
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│              RADOS (OSD 集群)                                            │
│                                                                           │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                     │
│  │   OSD 0     │  │   OSD 1     │  │   OSD 2     │  ...                │
│  │             │  │             │  │             │                      │
│  │ BlueStore   │  │ BlueStore   │  │ BlueStore   │                      │
│  └─────────────┘  └─────────────┘  └─────────────┘                     │
│         │                │                │                              │
│         ▼                ▼                ▼                              │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐                     │
│  │  物理磁盘   │  │  物理磁盘   │  │  物理磁盘   │                     │
│  │  /dev/sdb   │  │  /dev/sdc   │  │  /dev/sdd   │                     │
│  └─────────────┘  └─────────────┘  └─────────────┘                     │
└─────────────────────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════════════════
                    二、RBD Image 到 RADOS 对象映射
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────┐
│  RBD Image: myimage (10 GB, order=22, object_size=4MB)                  │
│  ID: 12abc345...                                                         │
└─────────────────────────────────────────────────────────────────────────┘
                             │
                             │ 映射
                             ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                   RADOS 对象 (Pool: rbd)                                 │
│                                                                           │
│  元数据对象：                                                             │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │ rbd_header.12abc345                                            │     │
│  │ ┌────────────────────────────────────────────────────────────┐ │     │
│  │ │ • size: 10737418240 (10 GB)                                │ │     │
│  │ │ • object_prefix: rbd_data.12abc345                         │ │     │
│  │ │ • order: 22 (4 MB objects)                                 │ │     │
│  │ │ • features: layering, exclusive-lock, object-map, ...      │ │     │
│  │ │ • flags: 0                                                 │ │     │
│  │ │ • snapshots: []                                            │ │     │
│  │ │ • parent: (if cloned)                                      │ │     │
│  │ │ • stripe_unit: 4194304 (4 MB)                              │ │     │
│  │ │ • stripe_count: 1                                          │ │     │
│  │ │ • create_timestamp: 2025-01-15 10:30:00                    │ │     │
│  │ └────────────────────────────────────────────────────────────┘ │     │
│  └────────────────────────────────────────────────────────────────┘     │
│                                                                           │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │ rbd_id.myimage                                                 │     │
│  │   → "12abc345"  (Name → ID 映射)                              │     │
│  └────────────────────────────────────────────────────────────────┘     │
│                                                                           │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │ rbd_object_map.12abc345                                        │     │
│  │   → BitVector<2> (每个对象 2 bit 状态)                        │     │
│  │      [EXISTS, EXISTS, NONEXISTENT, EXISTS, ...]                │     │
│  └────────────────────────────────────────────────────────────────┘     │
│                                                                           │
│  数据对象 (2560 个，10GB / 4MB)：                                        │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │ rbd_data.12abc345.0000000000000000  (Object 0)                 │     │
│  │   [0 MB, 4 MB)                                                 │     │
│  └────────────────────────────────────────────────────────────────┘     │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │ rbd_data.12abc345.0000000000000001  (Object 1)                 │     │
│  │   [4 MB, 8 MB)                                                 │     │
│  └────────────────────────────────────────────────────────────────┘     │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │ rbd_data.12abc345.0000000000000002  (Object 2)                 │     │
│  │   [8 MB, 12 MB)                                                │     │
│  └────────────────────────────────────────────────────────────────┘     │
│                         ...                                              │
│  ┌────────────────────────────────────────────────────────────────┐     │
│  │ rbd_data.12abc345.0000000000000a3f  (Object 2559)              │     │
│  │   [10236 MB, 10240 MB)                                         │     │
│  └────────────────────────────────────────────────────────────────┘     │
└─────────────────────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════════════════
                    三、I/O 请求处理详细流程
═══════════════════════════════════════════════════════════════════════════════

场景：写入 8MB 数据到偏移 10MB

应用程序
  │
  │ write(fd, buffer, 8MB) @ offset 10MB
  ▼
┌───────────────────────────────────────────────────────────────────────┐
│ 1. API 入口 (librbd.cc)                                               │
│                                                                        │
│    rbd_write(image, 10*1024*1024, 8*1024*1024, buf)                  │
│                                                                        │
│    创建 AioCompletion                                                  │
│    调用 api::Io::aio_write()                                          │
└───────────────────────┬───────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────────────┐
│ 2. 构造 ImageDispatchSpec (api/Io.cc)                                 │
│                                                                        │
│    ImageDispatchSpec::create_write(                                   │
│      offset: 10MB,                                                    │
│      length: 8MB,                                                     │
│      data: bufferlist(8MB)                                            │
│    )                                                                  │
│                                                                        │
│    spec->send()                                                       │
└───────────────────────┬───────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────────────┐
│ 3. ImageDispatcher 调度 (io/ImageDispatcher.cc)                       │
│                                                                        │
│    遍历 Dispatch 链：                                                  │
│                                                                        │
│    ┌────────────────────────────────────────────────────────────┐    │
│    │ QosImageDispatch::write()                                  │    │
│    │ • 检查 IOPS/BPS 限制                                       │    │
│    │ • 如果超限 → 排队                                          │    │
│    │ • 否则 → 放行                                              │    │
│    └────────────────────────┬───────────────────────────────────┘    │
│                             │                                         │
│                             ▼                                         │
│    ┌────────────────────────────────────────────────────────────┐    │
│    │ WriteBlockImageDispatch::write()                           │    │
│    │ • 检查是否有阻塞写入的操作 (如 resize)                     │    │
│    │ • 如果有 → 等待                                            │    │
│    │ • 否则 → 放行                                              │    │
│    └────────────────────────┬───────────────────────────────────┘    │
│                             │                                         │
│                             ▼                                         │
│    ┌────────────────────────────────────────────────────────────┐    │
│    │ RefreshImageDispatch::write()                              │    │
│    │ • 检查元数据是否需要刷新                                   │    │
│    │ • 如果需要 → 刷新后放行                                    │    │
│    │ • 否则 → 放行                                              │    │
│    └────────────────────────┬───────────────────────────────────┘    │
│                             │                                         │
│                             ▼                                         │
│    ┌────────────────────────────────────────────────────────────┐    │
│    │ ExclusiveLockImageDispatch::write()                        │    │
│    │ • 检查是否持有排他锁                                       │    │
│    │ • 如果没有 → 获取锁                                        │    │
│    │ • 如果有 → 放行                                            │    │
│    └────────────────────────┬───────────────────────────────────┘    │
│                             │                                         │
│                             ▼                                         │
│    ┌────────────────────────────────────────────────────────────┐    │
│    │ WriteLogImageDispatch::write()                             │    │
│    │ • 如果启用 PWL                                             │    │
│    │   ├─ 写入持久化写日志 (SSD/PMEM)                           │    │
│    │   ├─ 返回成功 ✓ (快速路径)                                │    │
│    │   └─ 后台刷新到 RADOS                                      │    │
│    │ • 否则 → 放行                                              │    │
│    └────────────────────────┬───────────────────────────────────┘    │
│                             │                                         │
│                             ▼                                         │
│    ┌────────────────────────────────────────────────────────────┐    │
│    │ ImageDispatch::write()                                     │    │
│    │ • 最终调度器                                               │    │
│    │ • 转发到 ImageRequest                                      │    │
│    └────────────────────────────────────────────────────────────┘    │
└───────────────────────┬───────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────────────┐
│ 4. Image 请求处理 (io/ImageRequest.cc)                                │
│                                                                        │
│    ImageWriteRequest::send()                                          │
│                                                                        │
│    地址映射：                                                          │
│    ┌────────────────────────────────────────────────────────────┐    │
│    │ Image offset: 10MB, length: 8MB                            │    │
│    │ Object size: 4MB (order=22)                                │    │
│    │                                                             │    │
│    │ 计算：                                                      │    │
│    │   start_object = 10MB >> 22 = 2                            │    │
│    │   start_offset = 10MB & (4MB-1) = 2MB                      │    │
│    │   end_object = (10MB+8MB-1) >> 22 = 4                      │    │
│    │                                                             │    │
│    │ 结果：                                                      │    │
│    │   Object 2: [2MB, 4MB) → 2MB 数据                          │    │
│    │   Object 3: [0, 4MB)   → 4MB 数据                          │    │
│    │   Object 4: [0, 2MB)   → 2MB 数据                          │    │
│    └────────────────────────────────────────────────────────────┘    │
│                                                                        │
│    创建 3 个 ObjectRequest：                                          │
│    ├─ ObjectWriteRequest(object_no=2, offset=2MB, len=2MB)           │
│    ├─ ObjectWriteRequest(object_no=3, offset=0,   len=4MB)           │
│    └─ ObjectWriteRequest(object_no=4, offset=0,   len=2MB)           │
└───────────────────────┬───────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────────────┐
│ 5. ObjectDispatcher 调度 (io/ObjectDispatcher.cc)                     │
│                                                                        │
│    调度链：                                                            │
│    ├─ CryptoObjectDispatch          (加密，如果启用)                  │
│    ├─ ObjectCacherObjectDispatch    (对象缓存，如果启用)              │
│    └─ SimpleSchedulerObjectDispatch (调度)                            │
└───────────────────────┬───────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────────────┐
│ 6. Object 请求处理 (io/ObjectRequest.cc)                              │
│                                                                        │
│    以 Object 2 为例：                                                  │
│                                                                        │
│    ObjectWriteRequest::send()                                         │
│    ┌────────────────────────────────────────────────────────────┐    │
│    │ a) 检查分层 (has_parent())                                 │    │
│    │    • 如果有父镜像且对象不存在 → Copyup                     │    │
│    │    • 否则 → 继续                                           │    │
│    │                                                             │    │
│    │ b) 更新 Object Map (如果启用)                              │    │
│    │    pre_write_object_map_update()                           │    │
│    │    • 设置对象状态为 PENDING                                │    │
│    │                                                             │    │
│    │ c) 构造 librados WriteOp                                   │    │
│    │    neorados::WriteOp write_op;                             │    │
│    │    write_op.write(offset=2MB, data=2MB);                   │    │
│    │    write_op.set_op_flags(flags);                           │    │
│    │                                                             │    │
│    │ d) 发送到 RADOS                                            │    │
│    │    m_ictx->rados_api.execute(                              │    │
│    │      object_name: "rbd_data.12abc345.0000000000000002",    │    │
│    │      pool: "rbd",                                          │    │
│    │      write_op,                                             │    │
│    │      completion                                            │    │
│    │    )                                                        │    │
│    │                                                             │    │
│    │ e) 等待回调                                                │    │
│    │    handle_write() → 更新 Object Map 为 EXISTS             │    │
│    └────────────────────────────────────────────────────────────┘    │
└───────────────────────┬───────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────────────┐
│ 7. librados 处理 (librados/)                                          │
│                                                                        │
│    对于每个对象：                                                      │
│    ┌────────────────────────────────────────────────────────────┐    │
│    │ a) CRUSH 计算                                              │    │
│    │    object_name: "rbd_data.12abc345.0000000000000002"       │    │
│    │    → hash() → PG 2.3f2                                     │    │
│    │    → CRUSH(2.3f2) → [OSD 5, OSD 12, OSD 23]              │    │
│    │    → Primary: OSD 5                                        │    │
│    │                                                             │    │
│    │ b) 构造 MOSDOp 消息                                        │    │
│    │    • 目标：OSD 5                                           │    │
│    │    • 操作：WRITE (offset=2MB, len=2MB)                     │    │
│    │    • 数据：bufferlist(2MB)                                 │    │
│    │                                                             │    │
│    │ c) 发送到 OSD 5                                            │    │
│    │    • TCP 连接                                              │    │
│    │    • 发送消息                                              │    │
│    │                                                             │    │
│    │ d) 等待副本确认                                            │    │
│    │    • OSD 5 写入本地 + 复制到 OSD 12, 23                    │    │
│    │    • 收到所有副本确认                                      │    │
│    │    • 返回 MOSDOpReply (成功)                               │    │
│    │                                                             │    │
│    │ e) 触发回调                                                │    │
│    │    → ObjectRequest::handle_write()                         │    │
│    │    → ImageRequest::handle_write()                          │    │
│    │    → AioCompletion::complete()                             │    │
│    └────────────────────────────────────────────────────────────┘    │
└───────────────────────┬───────────────────────────────────────────────┘
                        │
                        ▼
┌───────────────────────────────────────────────────────────────────────┐
│ 8. 完成回调                                                            │
│                                                                        │
│    所有 3 个 ObjectRequest 完成后：                                   │
│    ├─ ImageRequest 完成                                               │
│    ├─ AioCompletion 完成                                              │
│    └─ 应用程序收到成功 ✓                                              │
└───────────────────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════════════════
                    四、快照与克隆架构
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────┐
│                     快照机制                                             │
└─────────────────────────────────────────────────────────────────────────┘

时间线：
────────────────────────────────────────────────────────────────────────

T0: 创建 Image
┌──────────────────────────────────────┐
│ pool/parent                           │
│                                      │
│ rbd_data.<parent_id>.0000000000      │
│ rbd_data.<parent_id>.0000000001      │
│ rbd_data.<parent_id>.0000000002      │
│ ...                                  │
└──────────────────────────────────────┘
        │
        │ $ rbd snap create pool/parent@snap1
        ▼
T1: 创建快照
┌──────────────────────────────────────────────────────────────────────┐
│ pool/parent                                                           │
│                                                                       │
│ rbd_header.<parent_id>                                               │
│   snapshots:                                                         │
│   ├─ snap_id: 10                                                     │
│   ├─ snap_name: "snap1"                                              │
│   ├─ snap_namespace: user                                            │
│   ├─ size: 10 GB                                                     │
│   └─ timestamp: 2025-01-15 10:00:00                                  │
│                                                                       │
│ RADOS 快照 (Pool 级别)：                                             │
│   rbd_data.<parent_id>.0000000000@snap1                              │
│   rbd_data.<parent_id>.0000000001@snap1                              │
│   rbd_data.<parent_id>.0000000002@snap1                              │
│   ...                                                                │
│                                                                       │
│ HEAD (当前状态)：                                                     │
│   rbd_data.<parent_id>.0000000000 (HEAD)                             │
│   rbd_data.<parent_id>.0000000001 (HEAD)                             │
│   rbd_data.<parent_id>.0000000002 (HEAD)                             │
│   ...                                                                │
└──────────────────────────────────────────────────────────────────────┘
        │
        │ $ rbd snap protect pool/parent@snap1
        ▼
T2: 保护快照
┌──────────────────────────────────────────────────────────────────────┐
│ snap_id 10:                                                           │
│   protected: true  ✓                                                 │
└──────────────────────────────────────────────────────────────────────┘
        │
        │ $ rbd clone pool/parent@snap1 pool/child
        ▼
T3: 创建克隆
┌──────────────────────────────────────────────────────────────────────┐
│ pool/child (克隆 Image)                                               │
│                                                                       │
│ rbd_header.<child_id>                                                │
│   parent_info:                                                       │
│   ├─ pool_id: rbd                                                    │
│   ├─ image_id: <parent_id>                                           │
│   ├─ snap_id: 10 (snap1)                                             │
│   └─ overlap: 10 GB                                                  │
│                                                                       │
│ 数据对象：(初始时不存在)                                             │
│   (无对象)                                                           │
│                                                                       │
│ 读取时：                                                              │
│   child 对象不存在 → 从 parent@snap1 读取                            │
└──────────────────────────────────────────────────────────────────────┘


┌─────────────────────────────────────────────────────────────────────────┐
│                     Copyup 流程                                          │
└─────────────────────────────────────────────────────────────────────────┘

场景：写入 child 的 Object 2

┌──────────────────────────────────────────────────────────────────────┐
│ 1. ObjectWriteRequest::send()                                         │
│                                                                       │
│    检查：                                                             │
│    • has_parent() → true                                             │
│    • object_exists(2) → false                                        │
│    • offset < parent_overlap → true                                  │
│    → 需要 Copyup                                                     │
└────────────────────────────┬─────────────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────────────┐
│ 2. CopyupRequest::send()                                              │
│                                                                       │
│    a) 从父镜像读取完整对象                                            │
│    ┌────────────────────────────────────────────────────────────┐   │
│    │ read_from_parent():                                        │   │
│    │   image: pool/parent                                       │   │
│    │   snap_id: 10 (snap1)                                      │   │
│    │   object: rbd_data.<parent_id>.0000000000000002@snap1      │   │
│    │   offset: 0                                                │   │
│    │   length: 4MB                                              │   │
│    │   → parent_data (4MB)                                      │   │
│    └────────────────────────────────────────────────────────────┘   │
│                                                                       │
│    b) 合并新数据                                                      │
│    ┌────────────────────────────────────────────────────────────┐   │
│    │ 假设写入：offset=1MB, length=1MB, data=new_data           │   │
│    │                                                             │   │
│    │ merged_data:                                                │   │
│    │   [0, 1MB)   = parent_data[0, 1MB)    (保持)              │   │
│    │   [1MB, 2MB) = new_data               (新写入) ✓          │   │
│    │   [2MB, 4MB) = parent_data[2MB, 4MB)  (保持)              │   │
│    └────────────────────────────────────────────────────────────┘   │
│                                                                       │
│    c) 写入到子镜像                                                    │
│    ┌────────────────────────────────────────────────────────────┐   │
│    │ write_to_child():                                          │   │
│    │   object: rbd_data.<child_id>.0000000000000002             │   │
│    │   offset: 0                                                │   │
│    │   length: 4MB                                              │   │
│    │   data: merged_data                                        │   │
│    │   → 成功 ✓                                                 │   │
│    └────────────────────────────────────────────────────────────┘   │
│                                                                       │
│    d) 更新 Object Map                                                │
│    ┌────────────────────────────────────────────────────────────┐   │
│    │ object_map.update(2, OBJECT_EXISTS)                        │   │
│    └────────────────────────────────────────────────────────────┘   │
└────────────────────────────┬─────────────────────────────────────────┘
                             │
                             ▼
┌──────────────────────────────────────────────────────────────────────┐
│ 3. 完成                                                               │
│                                                                       │
│    • child 现在拥有 Object 2 的完整副本                               │
│    • 后续读写直接访问 child，无需访问 parent                          │
└───────────────────────────────────────────────────────────────────────┘


┌─────────────────────────────────────────────────────────────────────────┐
│                     读取流程对比                                         │
└─────────────────────────────────────────────────────────────────────────┘

读取 Object 3 (未 Copyup):
───────────────────────────────────────────────────────────────────────
app → ObjectReadRequest::read_object()
       ↓
     尝试从 child 读取：rbd_data.<child_id>.0000000000000003
       ↓
     -ENOENT (对象不存在)
       ↓
     ObjectReadRequest::read_parent()
       ↓
     从 parent@snap1 读取：rbd_data.<parent_id>.0000000000000003@snap1
       ↓
     返回 parent 数据 ✓

读取 Object 2 (已 Copyup):
───────────────────────────────────────────────────────────────────────
app → ObjectReadRequest::read_object()
       ↓
     从 child 读取：rbd_data.<child_id>.0000000000000002
       ↓
     成功 ✓ (直接返回，无需访问 parent)


═══════════════════════════════════════════════════════════════════════════════
                    五、缓存架构
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────┐
│              Object Cacher (对象缓存)                                    │
└─────────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────────┐
│ 应用 I/O                                                                │
│    │                                                                    │
│    ▼                                                                    │
│ ObjectCacherObjectDispatch                                             │
│    │                                                                    │
│    ├─→ 读取                                                            │
│    │   ├─ 命中缓存 → 返回缓存数据 ✓                                    │
│    │   └─ 未命中 → 从 OSD 读取 → 填充缓存 → 返回                       │
│    │                                                                    │
│    └─→ 写入                                                            │
│        ├─ Writeback 模式：                                             │
│        │  ├─ 写入缓存                                                  │
│        │  ├─ 立即返回 ✓ (快)                                           │
│        │  └─ 后台刷新到 OSD                                            │
│        │                                                                │
│        └─ Writethrough 模式：                                          │
│           ├─ 写入缓存 + OSD                                            │
│           └─ 等待 OSD 确认后返回 (安全)                                │
└────────────────────────────────────────────────────────────────────────┘
        │
        ▼
┌────────────────────────────────────────────────────────────────────────┐
│ ObjectCacher (缓存管理器)                                              │
│                                                                         │
│ ┌─────────────────────────────────────────────────────────────────┐   │
│ │ Object Cache (LRU)                                              │   │
│ │                                                                  │   │
│ │  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────┐ │   │
│ │  │ Object 0         │  │ Object 1         │  │ Object 2     │ │   │
│ │  │                  │  │                  │  │              │ │   │
│ │  │ ┌──────────────┐ │  │ ┌──────────────┐ │  │ ┌──────────┐ │ │   │
│ │  │ │ BufferHead   │ │  │ │ BufferHead   │ │  │ │BufferHead│ │ │   │
│ │  │ │ [0, 64K]     │ │  │ │ [0, 64K]     │ │  │ │[0, 64K]  │ │ │   │
│ │  │ │ state: CLEAN │ │  │ │ state: DIRTY │ │  │ │state:CLEAN│ │ │   │
│ │  │ │ data: ...    │ │  │ │ data: ...    │ │  │ │data: ... │ │ │   │
│ │  │ └──────────────┘ │  │ └──────────────┘ │  │ └──────────┘ │ │   │
│ │  │                  │  │                  │  │              │ │   │
│ │  │ ┌──────────────┐ │  │ ┌──────────────┐ │  │              │ │   │
│ │  │ │ BufferHead   │ │  │ │ BufferHead   │ │  │              │ │   │
│ │  │ │ [64K, 128K]  │ │  │ │ [64K, 128K]  │ │  │              │ │   │
│ │  │ │ state: CLEAN │ │  │ │ state: DIRTY │ │  │              │ │   │
│ │  │ │ data: ...    │ │  │ │ data: ...    │ │  │              │ │   │
│ │  │ └──────────────┘ │  │ └──────────────┘ │  │              │ │   │
│ │  └──────────────────┘  └──────────────────┘  └──────────────┘ │   │
│ │                                                                  │   │
│ │  缓存策略：                                                       │   │
│ │  • 粒度：64KB BufferHead                                         │   │
│ │  • 淘汰：LRU (Least Recently Used)                               │   │
│ │  • 大小限制：rbd_cache_max_size (默认 32 MB)                     │   │
│ │  • 脏页限制：rbd_cache_max_dirty (默认 24 MB)                    │   │
│ └──────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│ Flusher (后台刷新线程)                                                 │
│ ┌──────────────────────────────────────────────────────────────────┐  │
│ │ 定期检查脏页：                                                    │  │
│ │ • 超过 max_dirty → 刷新最老的脏页                                │  │
│ │ • 超过 max_dirty_age → 刷新超时的脏页                            │  │
│ │ • Flush 请求 → 刷新所有脏页                                      │  │
│ └──────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘


┌─────────────────────────────────────────────────────────────────────────┐
│              PWL (Persistent Write Log) - 持久化写日志                   │
└─────────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────────┐
│ 应用写入                                                                │
│    │                                                                    │
│    ▼                                                                    │
│ WriteLogImageDispatch                                                  │
│    │                                                                    │
│    ├─→ 1. 分配日志条目                                                 │
│    │    • entry_id = next_entry++                                      │
│    │    • entry_offset = 分配空间                                      │
│    │                                                                    │
│    ├─→ 2. 写入本地 SSD/PMEM                                            │
│    │    • WriteLog::append()                                           │
│    │    • 持久化到本地设备                                             │
│    │                                                                    │
│    ├─→ 3. 返回成功 ✓ (快速路径，~100us)                               │
│    │                                                                    │
│    └─→ 4. 后台刷新线程                                                 │
│         • 批量收集日志条目                                             │
│         • 刷新到 RADOS                                                 │
│         • 释放日志空间                                                 │
└────────────────────────────────────────────────────────────────────────┘
        │
        ▼
┌────────────────────────────────────────────────────────────────────────┐
│ WriteLog (环形缓冲区)                                                   │
│                                                                         │
│ ┌──────────────────────────────────────────────────────────────────┐  │
│ │ SSD/PMEM Device (/dev/nvme0n1)                                   │  │
│ │                                                                   │  │
│ │  Header (固定大小)                                                │  │
│ │  ┌───────────────────────────────────────────────────────────┐  │  │
│ │  │ • log_size: 10 GB                                         │  │  │
│ │  │ • first_valid_entry: 100                                  │  │  │
│ │  │ • num_log_entries: 200                                    │  │  │
│ │  │ • first_free_entry: 300                                   │  │  │
│ │  └───────────────────────────────────────────────────────────┘  │  │
│ │                                                                   │  │
│ │  Log Entries (环形缓冲区)                                         │  │
│ │  ┌─────────────────────────────────────────────────────────────┐│  │
│ │  │ Entry 100: [offset=8MB, len=4KB, data=..., checksum=...]   ││  │
│ │  │ Entry 101: [offset=12MB, len=8KB, data=..., checksum=...]  ││  │
│ │  │ Entry 102: [offset=16MB, len=4KB, data=..., checksum=...]  ││  │
│ │  │ ...                                                         ││  │
│ │  │ Entry 299: [offset=64MB, len=4KB, data=..., checksum=...]  ││  │
│ │  │                                                             ││  │
│ │  │ ┌───────────────────────────────────────────────────────┐ ││  │
│ │  │ │  Sync Point (同步点)                                  │ ││  │
│ │  │ │  • entry_id: 200                                      │ ││  │
│ │  │ │  • prior_sync_gen: 5                                  │ ││  │
│ │  │ │  • timestamp: 2025-01-15 10:30:00                     │ ││  │
│ │  │ │  • 用于崩溃恢复                                       │ ││  │
│ │  │ └───────────────────────────────────────────────────────┘ ││  │
│ │  └─────────────────────────────────────────────────────────────┘│  │
│ └───────────────────────────────────────────────────────────────────┘  │
│                                                                         │
│ WriteLog Operations:                                                   │
│ ┌──────────────────────────────────────────────────────────────────┐  │
│ │ append(offset, length, data):                                    │  │
│ │   • 分配条目                                                      │  │
│ │   • 写入数据 + 元数据                                             │  │
│ │   • fsync() 或 PMEM flush                                        │  │
│ │   • 返回 ✓                                                       │  │
│ │                                                                   │  │
│ │ flush():                                                          │  │
│ │   • 将日志条目刷新到 RADOS                                        │  │
│ │   • 标记为已刷新                                                  │  │
│ │   • 释放日志空间                                                  │  │
│ │                                                                   │  │
│ │ sync_point():                                                     │  │
│ │   • 创建同步点                                                    │  │
│ │   • 标记一致性边界                                                │  │
│ │                                                                   │  │
│ │ replay():                                                         │  │
│ │   • 崩溃恢复时使用                                                │  │
│ │   • 从最后一个 Sync Point 开始重放                                │  │
│ └──────────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────────┘

性能对比：
────────────────────────────────────────────────────────────────────────
                    无 PWL            有 PWL (SSD)       有 PWL (PMEM)
写延迟 (4KB)         ~2ms             ~200us            ~50us
写 IOPS             ~500              ~5K               ~20K
适用场景            通用              写密集型          极端性能


═══════════════════════════════════════════════════════════════════════════════
                    六、特性功能架构
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────┐
│                     Object Map (对象映射)                                │
└─────────────────────────────────────────────────────────────────────────┘

存储：
┌────────────────────────────────────────────────────────────────────────┐
│ rbd_object_map.<image_id>                                               │
│                                                                         │
│ BitVector<2>: (每个对象 2 bit)                                         │
│ ┌───────────────────────────────────────────────────────────────────┐ │
│ │ Object 0: 01 (EXISTS)                                             │ │
│ │ Object 1: 01 (EXISTS)                                             │ │
│ │ Object 2: 00 (NONEXISTENT)                                        │ │
│ │ Object 3: 01 (EXISTS)                                             │ │
│ │ Object 4: 10 (PENDING)                                            │ │
│ │ Object 5: 11 (EXISTS_CLEAN)                                       │ │
│ │ ...                                                                │ │
│ └───────────────────────────────────────────────────────────────────┘ │
│                                                                         │
│ 状态定义：                                                              │
│   00 (NONEXISTENT)   = 对象不存在                                      │
│   01 (EXISTS)        = 对象存在                                        │
│   10 (PENDING)       = 对象操作中                                      │
│   11 (EXISTS_CLEAN)  = 对象存在且干净                                  │
│                                                                         │
│ 大小计算：                                                              │
│   10GB Image, 4MB objects → 2560 objects                               │
│   → 2560 * 2 bits = 5120 bits = 640 bytes                              │
└─────────────────────────────────────────────────────────────────────────┘

优化场景：

1. Resize (缩小)
   ┌────────────────────────────────────────────────────────────────┐
   │ Without Object Map:                                            │
   │   for i in [new_size/obj_size, old_size/obj_size):            │
   │     try_remove(object[i])  # 即使不存在也尝试                  │
   │   → N 次 RADOS 操作 (N=所有可能对象)                          │
   │                                                                 │
   │ With Object Map:                                               │
   │   for i in [new_size/obj_size, old_size/obj_size):            │
   │     if object_map[i] == EXISTS:                                │
   │       remove(object[i])                                        │
   │   → M 次 RADOS 操作 (M=实际存在对象)                          │
   │                                                                 │
   │ 加速：M << N (稀疏镜像时显著)                                  │
   └────────────────────────────────────────────────────────────────┘

2. Diff (差异计算)
   ┌────────────────────────────────────────────────────────────────┐
   │ Without Object Map:                                            │
   │   for each object:                                             │
   │     stat_object() → 查询是否存在                               │
   │   → N 次 RADOS stat 操作                                       │
   │                                                                 │
   │ With Object Map:                                               │
   │   read object_map                                              │
   │   for each object:                                             │
   │     if object_map[i] == EXISTS: → 差异                         │
   │   → 1 次 RADOS read + 内存操作                                 │
   │                                                                 │
   │ 加速：O(N) → O(1) RADOS 操作                                   │
   └────────────────────────────────────────────────────────────────┘


┌─────────────────────────────────────────────────────────────────────────┐
│                     Exclusive Lock (排他锁)                              │
└─────────────────────────────────────────────────────────────────────────┘

目的：保证只有一个客户端可以写入（支持高级特性）

实现：基于 cls_lock (RADOS 分布式锁)

┌────────────────────────────────────────────────────────────────────────┐
│ 锁状态机                                                                │
│                                                                         │
│  ┌──────────────┐                                                      │
│  │  UNLOCKED    │  (初始状态)                                          │
│  └──────┬───────┘                                                      │
│         │ acquire_lock()                                               │
│         ▼                                                               │
│  ┌──────────────┐                                                      │
│  │  ACQUIRING   │  (获取锁中)                                          │
│  │  • 发送 lock 请求到 OSD                                             │
│  │  • 等待确认                                                         │
│  └──────┬───────┘                                                      │
│         │ success                                                      │
│         ▼                                                               │
│  ┌──────────────┐                                                      │
│  │   LOCKED     │  (持有锁)                                            │
│  │  • 可以执行写入                                                     │
│  │  • 定期续约 (keepalive)                                             │
│  │  • 监听锁失效事件                                                   │
│  └──────┬───────┘                                                      │
│         │ release_lock() 或锁失效                                       │
│         ▼                                                               │
│  ┌──────────────┐                                                      │
│  │  RELEASING   │  (释放锁中)                                          │
│  └──────┬───────┘                                                      │
│         │                                                               │
│         └─→ UNLOCKED                                                   │
│                                                                         │
│ 异常情况：                                                              │
│  ┌──────────────┐                                                      │
│  │  ACQUIRING   │                                                      │
│  └──────┬───────┘                                                      │
│         │ conflict (其他客户端持有锁)                                   │
│         ▼                                                               │
│  ┌──────────────┐                                                      │
│  │  WAITING     │  (等待锁释放)                                        │
│  │  • 监听锁释放事件                                                   │
│  │  • 超时后尝试打破锁 (break_lock)                                    │
│  └──────────────┘                                                      │
└─────────────────────────────────────────────────────────────────────────┘

锁存储：
┌────────────────────────────────────────────────────────────────────────┐
│ rbd_header.<image_id>                                                   │
│                                                                         │
│ cls_lock 信息：                                                         │
│ {                                                                       │
│   "lock_name": "rbd_lock",                                             │
│   "type": "exclusive",                                                 │
│   "locker": {                                                          │
│     "entity": "client.4567",                                           │
│     "cookie": "auto 1234567890",                                       │
│     "address": "10.0.0.100:0/12345",                                   │
│     "expiration": "2025-01-15 10:35:00",                               │
│   }                                                                     │
│ }                                                                       │
└─────────────────────────────────────────────────────────────────────────┘

多客户端协调：
┌────────────────────────────────────────────────────────────────────────┐
│ 客户端 A                  客户端 B                  OSD                │
│    │                         │                       │                 │
│    │ acquire_lock()          │                       │                 │
│    ├────────────────────────────────────────────────>│                 │
│    │                         │                       │ 成功            │
│    │<────────────────────────────────────────────────┤                 │
│    │                         │                       │                 │
│    │ (持有锁)                │                       │                 │
│    │                         │                       │                 │
│    │                         │ acquire_lock()        │                 │
│    │                         ├──────────────────────>│                 │
│    │                         │                       │ -EBUSY          │
│    │                         │<──────────────────────┤                 │
│    │                         │                       │                 │
│    │                         │ (等待或打破锁)        │                 │
│    │                         │                       │                 │
│    │ release_lock()          │                       │                 │
│    ├────────────────────────────────────────────────>│                 │
│    │                         │                       │ 释放            │
│    │                         │                       │                 │
│    │                         │ 自动重试 acquire_lock()│                │
│    │                         ├──────────────────────>│                 │
│    │                         │                       │ 成功 ✓          │
│    │                         │<──────────────────────┤                 │
│    │                         │                       │                 │
│    │                         │ (现在持有锁)          │                 │
└────────────────────────────────────────────────────────────────────────┘

锁打破机制：
┌────────────────────────────────────────────────────────────────────────┐
│ 场景：客户端 A 崩溃，仍然持有锁                                         │
│                                                                         │
│ 客户端 B:                                                               │
│ 1. 尝试获取锁 → -EBUSY                                                 │
│ 2. 等待 timeout (如 60 秒)                                             │
│ 3. 检查 locker 是否仍然存活 (ping)                                     │
│ 4. 如果无响应 → break_lock()                                           │
│    • 将 client A 加入黑名单                                            │
│    • 强制释放锁                                                        │
│ 5. 重新获取锁 ✓                                                        │
└─────────────────────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════════════════
                    七、性能调优参数
═══════════════════════════════════════════════════════════════════════════════

┌─────────────────────────────────────────────────────────────────────────┐
│                     关键配置参数                                         │
└─────────────────────────────────────────────────────────────────────────┘

对象大小：
────────────────────────────────────────────────────────────────────────
rbd_default_order = 22
  → 对象大小 = 2^22 = 4 MB
  推荐：
  • SSD/NVMe: 20-22 (1-4 MB)
  • HDD: 22-24 (4-16 MB)

缓存：
────────────────────────────────────────────────────────────────────────
rbd_cache = true
  → 启用客户端缓存

rbd_cache_max_size = 33554432  (32 MB)
  → 最大缓存大小

rbd_cache_max_dirty = 25165824  (24 MB)
  → 最大脏页大小

rbd_cache_max_dirty_age = 1.0
  → 脏页最大年龄 (秒)

rbd_cache_writethrough_until_flush = true
  → 收到 flush 前使用 writethrough

QoS 限制：
────────────────────────────────────────────────────────────────────────
rbd_qos_iops_limit = 0  (无限制)
  → IOPS 限制

rbd_qos_bps_limit = 0  (无限制)
  → 带宽限制 (字节/秒)

rbd_qos_read_iops_limit = 0
  → 读 IOPS 限制

rbd_qos_write_iops_limit = 0
  → 写 IOPS 限制

预读：
────────────────────────────────────────────────────────────────────────
rbd_readahead_trigger_requests = 10
  → 触发预读的顺序请求数

rbd_readahead_max_bytes = 524288  (512 KB)
  → 最大预读字节数

rbd_readahead_disable_after_bytes = 52428800  (50 MB)
  → 读取超过此值后禁用预读

PWL (持久化写日志)：
────────────────────────────────────────────────────────────────────────
rbd_persistent_cache_mode = disabled
  → PWL 模式：disabled, ssd, pmem

rbd_persistent_cache_size = 10737418240  (10 GB)
  → PWL 大小

rbd_persistent_cache_log_periodic_stats = false
  → 是否记录 PWL 统计信息

并发：
────────────────────────────────────────────────────────────────────────
rbd_concurrent_management_ops = 10
  → 并发管理操作数

rbd_op_threads = 1
  → 操作线程数


═══════════════════════════════════════════════════════════════════════════════
                    八、监控与调试
═══════════════════════════════════════════════════════════════════════════════

性能计数器：
────────────────────────────────────────────────────────────────────────
$ ceph daemon /var/run/ceph/ceph-client.*.asok perf dump librbd
{
  "librbd": {
    "rd": 12345,              # 读操作数
    "rd_bytes": 51380224,     # 读字节数
    "rd_latency": {           # 读延迟
      "avgcount": 12345,
      "sum": 1.234,
      "avgtime": 0.0001
    },
    "wr": 6789,               # 写操作数
    "wr_bytes": 27852800,     # 写字节数
    "wr_latency": {           # 写延迟
      "avgcount": 6789,
      "sum": 13.456,
      "avgtime": 0.002
    },
    ...
  }
}

Image 统计：
────────────────────────────────────────────────────────────────────────
$ rbd du pool/image
NAME        PROVISIONED  USED
image       10 GiB       2.5 GiB

$ rbd diff pool/image
<offset>+<length> <state>
0+4194304 exists
4194304+4194304 exists
8388608+4194304 zero
...

调试日志：
────────────────────────────────────────────────────────────────────────
$ ceph config set client debug_rbd 20
$ ceph config set client debug_librbd 20

查看日志：
/var/log/ceph/ceph-client.*.log

═══════════════════════════════════════════════════════════════════════════════
                    总结
═══════════════════════════════════════════════════════════════════════════════

RBD 核心优势：
✓ 分层架构清晰 (API → Dispatch → Request → librados)
✓ 对象映射高效 (Image → 4MB Objects)
✓ 快照克隆强大 (COW + 分层共享)
✓ 缓存优化完善 (Object Cacher + PWL)
✓ 特性丰富 (Object Map, Exclusive Lock, Journaling, Mirroring)
✓ 性能可调 (QoS, Readahead, 并发控制)

适用场景：
• 虚拟机磁盘 (IaaS 云平台)
• 容器持久化存储 (Kubernetes CSI)
• 数据库存储 (MySQL, PostgreSQL, MongoDB)
• 高性能应用 (延迟敏感型工作负载)

RBD 是 Ceph 生态中最成熟、应用最广泛的块存储方案！🚀

